package com.easy.firebaseProcessor

import com.easy.firebase.SuperEasyEvent
import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.*
import me.eugeniomarletti.kotlin.metadata.KotlinMetadataUtils
import me.eugeniomarletti.kotlin.metadata.jvm.internalName
import me.eugeniomarletti.kotlin.processing.KotlinAbstractProcessor
import java.io.File
import javax.annotation.processing.Processor
import javax.annotation.processing.RoundEnvironment
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind
import javax.lang.model.element.TypeElement
import javax.lang.model.util.ElementFilter

@AutoService(Processor::class)
class SuperEasyAnnotationProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils {

    override fun getSupportedAnnotationTypes(): Set<String> {
        return setOf(SuperEasyEvent::class.java.canonicalName)
    }

    override fun getSupportedSourceVersion(): SourceVersion {
        return SourceVersion.latestSupported()
    }

    override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
        return try {

            roundEnv.getElementsAnnotatedWith(SuperEasyEvent::class.java).forEach { eachElement ->
                checkAnnotationClassType(eachElement)
                val outputDir: File = checkOutputDir()
                // do waht?
                val variableAsElement = typeUtils.asElement(eachElement.asType())
                val fieldsInArgument = ElementFilter.fieldsIn(variableAsElement.enclosedElements)

                val annotationArgs = variableAsElement.getAnnotation(SuperEasyEvent::class.java)


                //generate code
                generateFunction(eachElement)

            }
            true
        } catch (e: Exception) {
            error(e.message!!)
            false
        }

    }

    private fun generateFunction(classElement: Element) {

        val builder = FileSpec.builder("oo.eric.easy", "EricEasyUtil")

        generateFunc(classElement).forEach {
            builder.addFunction(it)
        }
        builder.addImport("com.google.firebase.analytics", "FirebaseAnalytics")
        builder.addImport("com.google.firebase.analytics", "FirebaseAnalytics.Param.*")
        builder.build()
            .writeTo(checkOutputDir())
    }

    fun generateFunc(classElement: Element): List<FunSpec> {

        val list = mutableListOf<FunSpec>()

        val funBuilder = FunSpec.builder("logEvent")
            .addModifiers(KModifier.PUBLIC)
            .addParameter("event", classElement.asType().asTypeName())
            .receiver(CLASS_NAME_FIREBASE_ANALAYTICS)

            .addStatement("val b = %T()", CLASS_NAME_BUNDLE)
            .addStatement(
                """
                b.putInt(FirebaseAnalytics.Param.ITEM_ID,%L)
                b.putString(FirebaseAnalytics.Param.ITEM_NAME,%S)""".trimIndent(),
                1001, "Apple"
            )
            .addStatement(
                "logEvent(%L,b)",
                "FirebaseAnalytics.Event.SELECT_CONTENT" //,"FirebaseAnalytics.Event.SELECT_CONTENT"
            )


        val f2B = FunSpec.builder("doYourBest")
            .receiver(ClassName("android.view", "View"))
            .addKdoc(
                CodeBlock.builder()
                    .addStatement(
                        "This shit is dog. [%T], %L",
                        ClassName("android.os", "Bundle"),
                        ClassName("android.os", "Bundle")

                    )
                    .addStatement(
                        """
                        This function is generated by iii, no to change it.
                    """.trimIndent()
                    )
                    .build()
            )
            .addTypeVariable(TypeVariableName.Companion.invoke("Pop"))
            .addParameter("bundle", ClassName("android.os", "Bundle"))
            .addParameter("popClass", ClassName("", "Pop"))
            .beginControlFlow("if(bundle != null)")
            .addStatement("val a = 0")
            .addStatement("val b = 0")
            .addStatement("val c = a + b")
            .endControlFlow()
            .addStatement("val abc =\"999\"")



        list += funBuilder.build()
        list += f2B.build()
        return list
    }

    @Throws(IllegalStateException::class)
    private fun checkAnnotationClassType(element: Element) {
        when (element.kind) {
            ElementKind.CLASS -> {

            }
            else -> {
                val name = element.internalName
                val packages = element.enclosedElements
                val erms = "Can only be applied to functions,  element: $element , name: $name}"
                throwException(erms)
            }
        }
    }

    @Throws(IllegalStateException::class)
    fun throwException(errorMessage: String) {
        throw IllegalStateException(errorMessage)
    }

    //check output directory
    @Throws(IllegalStateException::class)
    private fun checkOutputDir(): File {
        return generatedDir
            ?: throw IllegalStateException("Can't find the target directory for generated Kotlin files.")
    }

    companion object {
        val CLASS_NAME_BUNDLE = ClassName("android.os", "Bundle")
        val CLASS_NAME_VIEW = ClassName("android.view", "View")
        val CLASS_NAME_FIREBASE_ANALAYTICS = ClassName("com.google.firebase.analytics", "FirebaseAnalytics")
    }
}